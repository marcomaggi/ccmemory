\input texinfo.tex
@c %**start of header
@setfilename ccmemory.info
@settitle CCMemory
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCMemory

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCMemory

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccmemory

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016, 2018, 2019

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.8.0
@set CCTESTS_VERSION            0.3.0

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing an interface to custom memory allocators.

This package supports @posix{} platforms.  This package depends on the package CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}.  To run the test suite: this package depends upon the
package CCTests, at least version @value{CCTESTS_VERSION}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccmemory: (ccmemory).       CCMemory a custom memory allocators
                              library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* allocators::                  The generic allocators @api{}.
* std::                         The standard allocator.
* handlers::                    Exception handlers.
* blocks::                      Blocks of memory.
* ascii::                       @ascii{} coded strings.
* utils::                       Utility definitions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing an interface to custom memory allocators.

This package supports @posix{} platforms.  This package depends on the package CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}.  To run the test suite: this package depends upon the
package CCTests, at least version @value{CCTESTS_VERSION}.

@value{PACKAGE} installs the single header file @file{ccmemory.h}.  All the function names in the
@api{} are prefixed with @code{ccmem_}; all the constant names are prefixed with @code{CCMEM_}; all
the type names are prefixed with @code{ccmem_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCMEMORY],[ccmemory >= 0.1])
@end example

@noindent
which will set the variables @code{CCMEMORY_LIBS} and @code{CCMEMORY_CFLAGS}.  To avoid problems
with @command{pkg-config}, we need to remember that:

@itemize
@item
The macro file defining @code{PKG_CHECK_MODULES} is installed by the package @code{pkg-config}; such
file usually is in one of the locations:

@center @file{/usr/share/aclocal/pkg.m4}
@center @file{/usr/local/share/aclocal/pkg.m4}

@item
The macro file is located by @command{aclocal}, which in turn is installed by the package @gnu{}
Automake; @command{aclocal} is used by @command{autoreconf}.  We must make sure that
@command{aclocal} finds the installed macro files; for this purpose we can use the environment
variable @env{ACLOCAL_PATH}; under a Bourne shell we can do this with:

@example
export ACLOCAL_PATH=/usr/local/share/aclocal:/usr/share/aclocal
@end example
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccmemory],[ccmem_version_string],,
  [AC_MSG_FAILURE([test for CCMemory library failed])])
AC_CHECK_HEADERS([ccmemory.h],,
  [AC_MSG_FAILURE([test for CCMemory header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccmem_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccmem_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccmem_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccmem_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node allocators
@chapter The generic allocators @api{}


@menu
* allocators typedefs::         Type definitions.
* allocators api::              Programming interface.
@end menu

@c page
@node allocators typedefs
@section Type definitions


@deftp {Struct Typedef} ccmem_allocator_t
Type of @code{struct} representing a memory allocator.  It has the following fields:

@table @code
@item ccmem_allocator_methods_t const * const methods
Pointer to a table of methods representing the behaviour of this allocator.
@end table

Instances of this type are meant to be wrapped in other @code{struct} to add state to the
allocator.  For example:

@example
typedef struct my_allocator_t   my_allocator_t;

struct my_allocator_t @{
  ccmem_allocator_t     base;
  void *                state;
@}
@end example
@end deftp


@deftp {Struct Typedef} ccmem_allocator_methods_t
Type of @code{struct} representing the methods of a memory allocator.  It has the following fields:

@table @code
@item ccmem_malloc_fun_t * const malloc
Pointer to function that allocates memory in a way similar to the standard @cfunc{malloc}.

@item ccmem_realloc_fun_t * const realloc
Pointer to function that reallocates memory in a way similar to the standard @cfunc{realloc}.

@item ccmem_calloc_fun_t * const calloc
Pointer to function that allocates memory in a way similar to the standard @cfunc{calloc}.

@item ccmem_free_fun_t * const free
Pointer to function that releases memory in a way similar to the standard @cfunc{free}.
@end table
@end deftp

@c ------------------------------------------------------------------------

@deftypefun {void *} ccmem_malloc_fun_t (cce_destination_t @var{L}, ccmem_allocator_t const * const @var{A}, size_t @var{size})
Type of function that allocates memory in a way similar to the standard @cfunc{malloc}.  The
function uses the allocator @var{A}.  If an error occurs: an exception is raised by jumping to the
location @var{L}.  Functions of this type never return @cnull{}.
@end deftypefun


@deftypefun {void *} ccmem_realloc_fun_t (cce_destination_t @var{L}, ccmem_allocator_t const * const @var{A}, void * @var{ptr}, size_t @var{newsize})
Type of function that reallocates memory in a way similar to the standard @cfunc{realloc}.  The
function uses the allocator @var{A}.  Only memory blocks allocated by @var{A} can be reallocated by
this function.  If an error occurs: an exception is raised by jumping to the location @var{L}.
Functions of this type never return @cnull{}.
@end deftypefun


@deftypefun {void *} ccmem_calloc_fun_t  (cce_destination_t @var{L}, ccmem_allocator_t const * const @var{A}, size_t @var{count}, size_t @var{eltsize})
Type of function that allocates memory in a way similar to the standard @cfunc{calloc}.  The
function uses the allocator @var{A}.  If an error occurs: an exception is raised by jumping to the
location @var{L}.  Functions of this type never return @cnull{}.
@end deftypefun


@deftypefun void ccmem_free_fun_t (ccmem_allocator_t const * const @var{A}, void * @var{ptr})
Type of function that releases memory in a way similar to the standard @cfunc{free}.  The function
uses the allocator @var{A}.  Only memory allocated using the allocator @var{A} can be released with
this function.

Functions of this type @strong{must not} raise exceptions.  If an allocator fails to release memory:
it should mark itself as ``in invalid state'' and fail to further allocate memory.
@end deftypefun

@c page
@node allocators api
@section Programming interface


@deftypefun {void *} ccmem_malloc (cce_destination_t @var{L}, ccmem_allocator_t const * const @var{A}, size_t @var{size})
Allocate memory in a way similar to the standard @cfunc{malloc}, using the allocator @var{A}.  If an
error occurs: an exception is raised by jumping to the location @var{L}.  This function never
returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccmem_realloc (cce_destination_t @var{L}, ccmem_allocator_t const * const @var{A}, void * @var{ptr}, size_t @var{newsize})
Reallocate memory in a way similar to the standard @cfunc{realloc}, using the allocator @var{A}.  If
an error occurs: an exception is raised by jumping to the location @var{L}.  This function never
returns @cnull{}.  Only blocks of memory allocated using @var{A} can be reallocated using @var{A}.
@end deftypefun


@deftypefun {void *} ccmem_calloc (cce_destination_t @var{L}, ccmem_allocator_t const * const @var{A}, size_t @var{count}, size_t @var{eltsize})
Allocate memory in a way similar to the standard @cfunc{calloc}, using the allocator @var{A}.  If an
error occurs: an exception is raised by jumping to the location @var{L}.  This function never
returns @cnull{}.
@end deftypefun


@deftypefun void ccmem_free (ccmem_allocator_t const * const @var{A}, void * @var{ptr})
Release memory in a way similar to the standard @cfunc{free}, using the allocator @var{A}.
@end deftypefun

@c page
@node std
@chapter The standard allocator


@deftypevr {Dynamic Constant} {ccmem_allocator_t const * const} ccmem_standard_allocator
Pointer to the standard memory allocator instance.  This allocator uses the standard functions
@cfunc{malloc}, @cfunc{realloc}, @cfunc{calloc} and @cfunc{free}.
@end deftypevr


@deftypefun {void *} ccmem_std_malloc (cce_destination_t @var{L}, size_t @var{size})
Allocate memory in a way similar to the standard @cfunc{malloc}, using the standard allocator.  If
an error occurs: an exception is raised by jumping to the location @var{L}.  This function never
returns @cnull{}.
@end deftypefun


@deftypefun {void *} ccmem_std_realloc (cce_destination_t @var{L}, void * @var{ptr}, size_t @var{newsize})
Reallocate memory in a way similar to the standard @cfunc{realloc}, using the standard allocator.
If an error occurs: an exception is raised by jumping to the location @var{L}.  This function never
returns @cnull{}.  Only blocks of memory allocated using the standard allocator can be reallocated
using this function.
@end deftypefun


@deftypefun {void *} ccmem_std_calloc (cce_destination_t @var{L}, size_t @var{count}, size_t @var{eltsize})
Allocate memory in a way similar to the standard @cfunc{calloc}, using the standard allocator.  If
an error occurs: an exception is raised by jumping to the location @var{L}.  This function never
returns @cnull{}.
@end deftypefun


@deftypefun void ccmem_std_free (void * @var{ptr})
Release memory in a way similar to the standard @cfunc{free}, using the standard allocator.
@end deftypefun

@c page
@node handlers
@chapter Exception handlers


Using the facilities of the library CCExceptions, it is possible to automatically release allocated
memory when exiting a location.


@deftp {Struct Typedef} ccmem_clean_handler_t
Type of clean exception handler that can release memory managed by a generic allocator.
@end deftp


@deftp {Struct Typedef} ccmem_error_handler_t
Type of error exception handler that can release memory managed by a generic allocator.
@end deftp

@menu
* handlers generic::            Exception handlers for generic allocators.
* handlers standard::           Exception handlers for the standard allocator.
@end menu

@c page
@node handlers generic
@section Exception handlers for generic allocators


@menu
* handlers generic malloc::     Guarded @cfunc{malloc} with generic allocators.
* handlers generic calloc::     Guarded @cfunc{calloc} with generic allocators.
* handlers generic realloc::    Guarded @cfunc{realloc} with generic allocators.
@end menu

@c page
@node handlers generic malloc
@subsection Guarded @cfunc{malloc} with generic allocators


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  void *      P = ccmem_malloc_guarded(L, P_H,
                    ccmem_standard_allocator, 4096);

  memset(P, 0, 4096);
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} ccmem_malloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{P_H}, ccmem_allocator_t const * @var{A}, size_t @var{size})
Wrapper for @cfunc{ccmem_malloc} that registers the allocated memory to be released by the handler
referenced by @var{P_H}.
@end deftypefun


@deftypefun {void *} ccmem_malloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{P_H}, ccmem_allocator_t const * @var{A}, size_t @var{size})
Wrapper for @cfunc{ccmem_malloc} that registers the allocated memory to be released by the handler
referenced by @var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccmem_malloc_guarded (cce_destination_t @var{L}, @var{P_H}, ccmem_allocator_t const * @var{A}, size_t @var{size})
If the argument @var{P_H} is a pointer of type:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_malloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node handlers generic calloc
@subsection Guarded @cfunc{calloc} with generic allocators


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  void *      P = ccmem_calloc_guarded(L, P_H,
                    ccmem_standard_allocator, 16, 4096);

  memset(P, 0, 16 * 4096);
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} ccmem_calloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{P_H}, ccmem_allocator_t const * @var{A}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{ccmem_calloc} that registers the allocated memory to be released by the handler
referenced by @var{P_H}.
@end deftypefun


@deftypefun {void *} ccmem_calloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{P_H}, ccmem_allocator_t const * @var{A}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{ccmem_calloc} that registers the allocated memory to be released by the handler
referenced by @var{P_H}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccmem_calloc_guarded (cce_destination_t @var{L}, @var{P_H}, ccmem_allocator_t const * @var{A}, size_t @var{count}, size_t @var{eltsize})
If the argument @var{P_H} is a pointer of type:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_calloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node handlers generic realloc
@subsection Guarded @cfunc{realloc} with generic allocators


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  void *      P = ccmem_malloc_guarded(L, P_H,
                    ccmem_standard_allocator, 4096);

  memset(P, 0, 4096);
  @{
    void *    Q = ccmem_realloc_guarded(L, P_H,
                    ccmem_standard_allocator, P, 2 * 4096);

    memset(Q, 0, 2 * 4096);
  @}
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} ccmem_realloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{P_H}, ccmem_allocator_t const * @var{A}, void * @var{P}, size_t @var{newsize})
Wrapper for @cfunc{ccmem_realloc} that registers the allocated memory to be released by the handler
referenced by @var{P_H}.  Such handler must be the @strong{same one} used in a previous call to
@cfunc{ccmem_malloc_guarded_clean}, @cfunc{ccmem_calloc_guarded_clean} or
@cfunc{ccmem_realloc_guarded_clean}.
@end deftypefun


@deftypefun {void *} ccmem_realloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{P_H}, ccmem_allocator_t const * @var{A}, void * @var{P}, size_t @var{newsize})
Wrapper for @cfunc{ccmem_realloc} that registers the allocated memory to be released by the handler
referenced by @var{P_H}.  Such handler must be the @strong{same one} used in a previous call to
@cfunc{ccmem_malloc_guarded_clean}, @cfunc{ccmem_calloc_guarded_clean} or
@cfunc{ccmem_realloc_guarded_clean}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccmem_realloc_guarded (cce_destination_t @var{L}, @var{P_H}, ccmem_allocator_t const * @var{A}, void * @var{P}, size_t @var{newsize})
If the argument @var{P_H} is a pointer of type:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_realloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node handlers standard
@section Exception handlers for the standard allocator


@menu
* handlers standard malloc::    Guarded @cfunc{malloc} with the
                                standard allocator.
* handlers standard calloc::    Guarded @cfunc{calloc} with the
                                standard allocator.
* handlers standard realloc::   Guarded @cfunc{realloc} with the
                                standard allocator.
@end menu

@c page
@node handlers standard malloc
@subsection Guarded @cfunc{malloc} with the standard allocator


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  void *      P = ccmem_std_malloc_guarded(L, P_H, 4096);

  memset(P, 0, 4096);
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} ccmem_std_malloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{P_H}, size_t @var{size})
Wrapper for @cfunc{ccmem_malloc_guarded_clean} that registers the allocated memory to be released by
the handler referenced by @var{P_H}, using the standard allocator.
@end deftypefun


@deftypefun {void *} ccmem_std_malloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{P_H}, size_t @var{size})
Wrapper for @cfunc{ccmem_malloc_guarded_error} that registers the allocated memory to be released by
the handler referenced by @var{P_H}, using the standard allocator.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccmem_std_malloc_guarded (cce_destination_t @var{L}, @var{P_H}, size_t @var{size})
If the argument @var{P_H} is a pointer of type:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_std_malloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_std_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node handlers standard calloc
@subsection Guarded @cfunc{calloc} with the standard allocator


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  void *      P = ccmem_std_calloc_guarded(L, P_H, 16, 4096);

  memset(P, 0, 16 * 4096);
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} ccmem_std_calloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{ccmem_calloc_guarded_clean} that registers the allocated memory to be released by
the handler referenced by @var{P_H}, using the standard allocator.
@end deftypefun


@deftypefun {void *} ccmem_std_calloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{P_H}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{ccmem_calloc_guarded_error} that registers the allocated memory to be released by
the handler referenced by @var{P_H}, using the standard allocator.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccmem_std_calloc_guarded (cce_destination_t @var{L}, @var{P_H}, size_t @var{count}, size_t @var{eltsize})
If the argument @var{P_H} is a pointer of type:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_std_calloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_std_calloc_guarded_error}.
@end table
@end deftypefn

@c page
@node handlers standard realloc
@subsection Guarded @cfunc{realloc} with the standard allocator


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  void *      P = ccmem_std_malloc_guarded(L, P_H, 4096);

  memset(P, 0, 4096);
  @{
    void *    Q = ccmem_std_realloc_guarded(L, P_H, P, 2 * 4096);

    memset(Q, 0, 2 * 4096);
  @}
  cce_run_body_handlers(L);
@}
@end example


@deftypefun {void *} ccmem_std_realloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{P_H}, void * @var{P}, size_t @var{newsize})
Wrapper for @cfunc{ccmem_realloc_guarded_clean} that registers the allocated memory to be released
by the handler referenced by @var{P_H}, using the standard allocator.  Such handler must be the
@strong{same one} used in a previous call to @cfunc{ccmem_std_malloc_guarded_clean},
@cfunc{ccmem_std_calloc_guarded_clean} or @cfunc{ccmem_std_realloc_guarded_clean}.
@end deftypefun


@deftypefun {void *} ccmem_std_realloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{P_H}, void * @var{P}, size_t @var{newsize})
Wrapper for @cfunc{ccmem_realloc_guarded_error} that registers the allocated memory to be released
by the handler referenced by @var{P_H}, using the standard allocator.  Such handler must be the
@strong{same one} used in a previous call to @cfunc{ccmem_std_malloc_guarded_clean} or
@cfunc{ccmem_std_calloc_guarded_clean} or @cfunc{ccmem_std_realloc_guarded_clean}.
@end deftypefun


@deftypefn {Preprocessor Macro} {void *} ccmem_std_realloc_guarded (cce_destination_t @var{L}, @var{P_H}, void * @var{P}, size_t @var{newsize})
If the argument @var{P_H} is a pointer of type:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_std_realloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_std_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node blocks
@chapter Blocks of memory


@deftp {Struct Typedef} ccmem_block_t
Type representing an memory.  Usually instances of this type are passed around by value.  It has the
following fields:

@table @code
@item size_t len
Number of octets in the string.

@item uint8_t * ptr
Pointer to the first octet in the block.
@end table
@end deftp

@menu
* blocks constructors::         Constructors for blocks.
* blocks predicates::           Predicates for blocks.
* blocks comparison::           Comparison between blocks.
* blocks operations::           Operations on blocks.
* blocks dynamic::              Dynamic memory allocation for blocks.
* blocks guarded::              Guarded memory allocation for blocks.
@end menu

@c page
@node blocks constructors
@section Constructors for blocks


@deftypefun ccmem_block_t ccmem_new_block (uint8_t * @var{ptr}, size_t @var{len})
Build and return a new instance, initialised with the given operands.
@end deftypefun


@deftypefun ccmem_block_t ccmem_new_block_null (void)
Build and return a new instance: the pointer field is set to @cnull{}; the length field is set to
zero.
@end deftypefun


@deftypefun ccmem_block_t ccmem_new_block_from_ascii (ccmem_ascii_t @var{S})
Build and return a new instance initialised with the fields from the given @ascii{} string.
@end deftypefun


@deftypefun ccmem_block_t ccmem_new_block_from_asciiz (ccmem_blockz_t @var{B})
Build and return a new instance initialised with the fields from the given @asciiz{} string.  The
block length includes the terminating zero.
@end deftypefun

@c page
@node blocks predicates
@section Predicates for blocks


@deftypefun bool ccmem_block_is_empty (ccmem_block_t const @var{S})
Return @ctrue{} if the block is empty, that is: the length is zero, the pointer is @strong{not}
@cnull{}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccmem_block_is_null (ccmem_block_t const @var{S})
Return @ctrue{} if the block is null, that is: the length is zero, the pointer is @cnull{};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node blocks comparison
@section Comparison between blocks


@deftypefun bool ccmem_block_equal (ccmem_block_t const @vari{S}, ccmem_block_t const @varii{S})
Return @ctrue{} if the strings have the same length and the same contents; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node blocks operations
@section Operations on blocks


@deftypefun void ccmem_block_clean_memory (ccmem_block_t @var{S})
Reset to zero all the characters in the string.
@end deftypefun


@deftypefun ccmem_block_t ccmem_block_shift (ccmem_block_t @var{B}, ssize_t @var{offset}, size_t @var{dim})
Imagine that @var{B} is referencing a block of memory holding objects of size @var{dim}; build and
return a new block referencing the object at @var{offset} objects forwards or backwards.

@example
#include <complex.h>

cce_location_t  L[1];

ccmem_block_t  B = ccmem_block_new(L, ccmem_standard_allocator,
  3 * sizeof(complex));

ccmem_block_t  X = ccmem_block_shift(B, +2, sizeof(complex));
ccmem_block_t  Y = ccmem_block_shift(X, -1, sizeof(complex));
@end example
@end deftypefun


@deftypefun ccmem_block_t ccmem_block_difference (ccmem_block_t @var{A}, ccmem_block_t @var{B})
Build and return a new block representing the difference @math{@var{A} - @var{B}}.  If @var{C} is
the returned block, this means:

@example
C.ptr = A.ptr
C.len = A.len - B.len
@end example

@var{A} and @var{B} must have the same pointer and @var{A} must reference a number of octets greater
than, or equal to, the one referenced by @var{B}, as in the following picture:

@example
                     A
|---------------------------------------|
|-----------------------|---------------|
           B                    C
@end example
@end deftypefun

@c page
@node blocks dynamic
@section Dynamic memory allocation for blocks


@deftypefun ccmem_block_t ccmem_block_malloc (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Use the given allocator to allocate enough memory to hold @var{len} octets and return a new instance
referencing the memory.  If an error occurs: raise an exception by performing a non--local exit to
@var{L}.
@end deftypefun


@deftypefun ccmem_block_t ccmem_block_realloc (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_block_t @var{S}, size_t @var{newlen})
Use the given allocator to reallocate the memory referenced by @var{S} to a new size.  Return a new
@struct{} instance referencing the reallocated memory.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void ccmem_block_free (ccmem_allocator_t const * @var{A}, ccmem_block_t @var{S})
Use the given allocator to release the memory referenced by @var{S}.
@end deftypefun

@c page
@node blocks guarded
@section Guarded memory allocation for blocks


@menu
* blocks guarded malloc::       Guarding memory allocated with @code{malloc}.
* blocks guarded realloc::      Guarding memory allocated with @code{realloc}.
@end menu

@c page
@node blocks guarded malloc
@subsection Guarding memory allocated with @code{malloc}


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t S_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_block_t  S = ccmem_block_malloc_guarded(L, S_H,
                       ccmem_standard_allocator, 4);

  ...
  cce_run_body_handlers(L);
@}
@end example


@deftypefun ccmem_block_t ccmem_block_malloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Adapter for @cfunc{ccmem_malloc_guarded_clean} that builds and returns a new blocks.
@end deftypefun


@deftypefun ccmem_block_t ccmem_block_malloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Adapter for @cfunc{ccmem_malloc_guarded_error} that builds and returns a new blocks.
@end deftypefun


@deftypefn {Preprocessor Macro} ccmem_block_t ccmem_block_malloc_guarded (cce_destination_t @var{L}, @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Preprocessor macro that builds and returns a new block.  If the argument @var{S_H} is a pointer to:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_block_malloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_block_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node blocks guarded realloc
@subsection Guarding memory allocated with @code{realloc}


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t S_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_block_t  S = ccmem_block_malloc_guarded(L, S_H,
                       ccmem_standard_allocator, 256);

  ...
  S = ccmem_block_realloc_guarded(L, S_H,
        ccmem_standard_allocator, S, 512);
  ...
  cce_run_body_handlers(L);
@}
@end example


@deftypefun ccmem_block_t ccmem_block_realloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_block_t @var{S}, size_t @var{newlen})
Adapter for @cfunc{ccmem_realloc_guarded_clean} that builds and returns a new block representing the
reallocation of @var{S}.  The given handler must be @strong{the same} handler used in a previous
call to the allocation function.
@end deftypefun


@deftypefun ccmem_block_t ccmem_block_realloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_block_t @var{S}, size_t @var{newlen})
Adapter for @cfunc{ccmem_realloc_guarded_error} that builds and returns a new block string
representing the reallocation of @var{S}.  The given handler must be @strong{the same} handler used
in a previous call to the allocation function.
@end deftypefun


@deftypefn {Preprocessor Macro} ccmem_block_t ccmem_block_realloc_guarded (cce_destination_t @var{L}, @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_block_t @var{S}, size_t @var{newlen})
Preprocessor macro that builds and returns a new block string representing the reallocation of
@var{S}.  The given handler must be @strong{the same} handler used in a previous call to the
allocation function.  If the argument @var{S_H} is a pointer to:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_block_realloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_block_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node ascii
@chapter @ascii{} coded strings


@menu
* ascii non-zero::              Non--zero terminated strings.
* ascii zero::                  Zero terminated strings.
@end menu

@c page
@node ascii non-zero
@section Non--zero terminated strings


@deftp {Struct Typedef} ccmem_ascii_t
Type representing an @ascii{} coded, non--zero terminated, string in memory.  Usually instances of
this type are passed around by value.  It has the following fields:

@table @code
@item size_t len
Number of characters in the string.

@item char * ptr
Pointer to the first character in the string.
@end table
@end deftp

@menu
* ascii non-zero constructors:: Constructors for @ascii{} strings.
* ascii non-zero predicates::   Predicates for @ascii{} strings.
* ascii non-zero comparison::   Comparison between @ascii{} strings.
* ascii non-zero operations::   Operations on @ascii{} strings.
* ascii non-zero dynamic::      Dynamic memory allocation for
                                @ascii{} strings.
* ascii non-zero guarded::      Guarded memory allocation for @ascii{}
                                strings.
@end menu

@c page
@node ascii non-zero constructors
@subsection Constructors for @ascii{} strings


@deftypefun ccmem_ascii_t ccmem_new_ascii (char * @var{ptr}, size_t @var{len})
Build and return a new instance, initialised with the given operands.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_new_ascii_empty (void)
Build and return a new instance, representing an empty string.  The pointer field references a
statically allocated empty string; the length field is set to zero.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_new_ascii_null (void)
Build and return a new instance: the pointer field is set to @cnull{}; the length field is set to
zero.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_new_ascii_from_str (char * @var{str})
Build and return a new instance, initialised with the given pointer to an @asciiz{} string.  The
length of the string is determined with a call to @cfunc{strlen}.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_new_ascii_from_block (ccmem_block_t @var{B})
Build and return a new instance initialised with the fields from the given block.  The block is
supposed to hold a valid @ascii{} string, with no zero characters inside.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_new_ascii_from_asciiz (ccmem_asciiz_t @var{B})
Build and return a new instance initialised with the fields from the given @asciiz{} string.
@end deftypefun

@c page
@node ascii non-zero predicates
@subsection Predicates for @ascii{} strings


@deftypefun bool ccmem_ascii_is_empty (ccmem_ascii_t const @var{S})
Return @ctrue{} if the string is empty, that is: the string length is zero, the string pointer is
non--@cnull{}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccmem_ascii_is_null (ccmem_ascii_t const @var{S})
Return @ctrue{} if the string is null, that is: the string length is zero, the string pointer is
@cnull{}; otherwise return @cfalse{}.
@end deftypefun

@c page
@node ascii non-zero comparison
@subsection Comparison between @ascii{} strings


@deftypefun bool ccmem_ascii_equal (ccmem_ascii_t const @vari{S}, ccmem_ascii_t const @varii{S})
Return @ctrue{} if the strings have the same length and the same contents; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node ascii non-zero operations
@subsection Operations on @ascii{} strings


@deftypefun void ccmem_ascii_clean_memory (ccmem_ascii_t @var{S})
Reset to zero all the characters in the string.
@end deftypefun

@c page
@node ascii non-zero dynamic
@subsection Dynamic memory allocation for @ascii{} strings


@deftypefun ccmem_ascii_t ccmem_ascii_malloc (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Use the given allocator to allocate enough memory to hold @var{len} characters and return a new
@struct{} instance referencing the memory.  If an error occurs: raise an exception by performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_ascii_realloc (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{S}, size_t @var{newlen})
Use the given allocator to reallocate the memory referenced by @var{S} to a new size.  Return a new
@struct{} instance referencing the reallocated memory.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void ccmem_ascii_free (ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{S})
Use the given allocator to release the memory referenced by @var{S}.
@end deftypefun

@c page
@node ascii non-zero guarded
@subsection Guarded memory allocation for @ascii{} strings


@menu
* ascii non-zero guarded malloc::  Guarding memory allocated with @code{malloc}.
* ascii non-zero guarded realloc:: Guarding memory allocated with @code{realloc}.
@end menu

@c page
@node ascii non-zero guarded malloc
@subsubsection Guarding memory allocated with @code{malloc}


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t S_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_ascii_t  S = ccmem_ascii_malloc_guarded(L, S_H,
                       ccmem_standard_allocator, 4);

  ...
  cce_run_body_handlers(L);
@}
@end example


@deftypefun ccmem_ascii_t ccmem_ascii_malloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Adapter for @cfunc{ccmem_malloc_guarded_clean} that builds and returns a new @ascii{} string.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_ascii_malloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Adapter for @cfunc{ccmem_malloc_guarded_error} that builds and returns a new @ascii{} string.
@end deftypefun


@deftypefn {Preprocessor Macro} ccmem_ascii_t ccmem_ascii_malloc_guarded (cce_destination_t @var{L}, @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Preprocessor macro that builds and returns a new @ascii{} string.  If the argument @var{S_H} is a
pointer to:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_ascii_malloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_ascii_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node ascii non-zero guarded realloc
@subsubsection Guarding memory allocated with @code{realloc}


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t S_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_ascii_t  S = ccmem_ascii_malloc_guarded(L, S_H,
                       ccmem_standard_allocator, 256);

  ...
  S = ccmem_ascii_realloc_guarded(L, S_H,
        ccmem_standard_allocator, S, 512);
  ...
  cce_run_body_handlers(L);
@}
@end example


@deftypefun ccmem_ascii_t ccmem_ascii_realloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{S}, size_t @var{newlen})
Adapter for @cfunc{ccmem_realloc_guarded_clean} that builds and returns a new @ascii{} string
representing the reallocation of @var{S}.  The given handler must be @strong{the same} handler used
in a previous call to the allocation function.
@end deftypefun


@deftypefun ccmem_ascii_t ccmem_ascii_realloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{S}, size_t @var{newlen})
Adapter for @cfunc{ccmem_realloc_guarded_error} that builds and returns a new @ascii{} string
representing the reallocation of @var{S}.  The given handler must be @strong{the same} handler used
in a previous call to the allocation function.
@end deftypefun


@deftypefn {Preprocessor Macro} ccmem_ascii_t ccmem_ascii_realloc_guarded (cce_destination_t @var{L}, @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{S}, size_t @var{newlen})
Preprocessor macro that builds and returns a new @ascii{} string representing the reallocation of
@var{S}.  The given handler must be @strong{the same} handler used in a previous call to the
allocation function.  If the argument @var{S_H} is a pointer to:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_ascii_realloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_ascii_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node ascii zero
@section Zero terminated strings


@deftp {Struct Typedef} ccmem_asciiz_t
Type representing an @ascii{} coded, zero terminated, string in memory; an @asciiz{} string.
Usually instances of this type are passed around by value.  It has the following fields:

@table @code
@item size_t len
Number of characters in the string, @strong{not} including the terminating zero.

@item char * ptr
Pointer to the first character in the string.
@end table
@end deftp

@menu
* ascii zero constructors::     Constructors for @ascii{} strings.
* ascii zero predicates::       Predicates for @ascii{} strings.
* ascii zero comparison::       Comparison between @ascii{} strings.
* ascii zero operations::       Operations on @ascii{} strings.
* ascii zero dynamic::          Dynamic memory allocation for
                                @ascii{} strings.
* ascii zero guarded::          Guarded memory allocation for @ascii{}
                                strings.
@end menu

@c page
@node ascii zero constructors
@subsection Constructors for @ascii{} strings


@deftypefun ccmem_asciiz_t ccmem_new_ascii (char * @var{ptr}, size_t @var{len})
Build and return a new instance, initialised with the given operands.  @var{len} must not include
the terminating zero.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_new_asciiz_empty (void)
Build and return a new instance, representing an empty string.  The pointer field references a
statically allocated, zero terminated, empty string; the length field is set to zero.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_new_asciiz_null (void)
Build and return a new instance: the pointer field is set to @cnull{}; the length field is set to
zero.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_new_asciiz_from_str (char * @var{str})
Build and return a new instance, initialised with the given pointer to an @asciiz{} string.  The
length of the string is determined with a call to @cfunc{strlen}.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_new_asciiz_from_block (ccmem_block_t @var{B})
Build and return a new instance initialised with the fields from the given block.  The block is
supposed to hold a valid @asciiz{} string, with no zero characters inside.  This function assumes
that the string in the block is zero--terminated and the terminating zero is an octet counted by the
block's length.
@end deftypefun

@c page
@node ascii zero predicates
@subsection Predicates for @ascii{} strings


@deftypefun bool ccmem_asciiz_is_empty (ccmem_asciiz_t const @var{S})
Return @ctrue{} if the string is empty, that is: the string length is zero, the string pointer is
non--@cnull{}, the string is zero terminated; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccmem_asciiz_is_null (ccmem_asciiz_t const @var{S})
Return @ctrue{} if the string is null, that is: the string length is zero, the string pointer is
@cnull{}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccmem_asciiz_is_terminated (ccmem_asciiz_t @var{S})
Return @ctrue{} if the string pointer is not @cnull{} and the string is zero terminated; otherwise
return @cfalse{}.
@end deftypefun

@c page
@node ascii zero comparison
@subsection Comparison between @ascii{} strings


@deftypefun bool ccmem_asciiz_equal (ccmem_asciiz_t const @vari{S}, ccmem_asciiz_t const @varii{S})
Return @ctrue{} if the strings have the same length and the same contents; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node ascii zero operations
@subsection Operations on @ascii{} strings


@deftypefun void ccmem_asciiz_clean_memory (ccmem_asciiz_t @var{S})
Reset to zero all the characters in the string.
@end deftypefun


@deftypefun void ccmem_asciiz_terminate (ccmem_asciiz_t @var{S})
Set to zero the octet after the last character in the string, making sure that the string is zero
terminated.
@end deftypefun

@c page
@node ascii zero dynamic
@subsection Dynamic memory allocation for @ascii{} strings


@deftypefun ccmem_asciiz_t ccmem_asciiz_malloc (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Use the given allocator to allocate enough memory to hold @var{len} characters, plus the terminating
zero, and return a new instance referencing the memory.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.  Make sure that the returned string is zero terminated.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_asciiz_realloc (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{S}, size_t @var{newlen})
Use the given allocator to reallocate the memory referenced by @var{S} to a new size; @var{newlen}
is meant @strong{not} to include the terminating zero.  Return a new instance referencing the
reallocated memory.  If an error occurs: raise an exception by performing a non--local exit to
@var{L}.  Make sure that the returned string is zero terminated.
@end deftypefun


@deftypefun void ccmem_asciiz_free (ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{S})
Use the given allocator to release the memory referenced by @var{S}.
@end deftypefun

@c page
@node ascii zero guarded
@subsection Guarded memory allocation for @ascii{} strings


@menu
* ascii zero guarded malloc::   Guarding memory allocated with @code{malloc}.
* ascii zero guarded realloc::  Guarding memory allocated with @code{realloc}.
@end menu

@c page
@node ascii zero guarded malloc
@subsubsection Guarding memory allocated with @code{malloc}


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t S_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  S = ccmem_asciiz_malloc_guarded(L, S_H,
                       ccmem_standard_allocator, 4);

  ...
  cce_run_body_handlers(L);
@}
@end example


@deftypefun ccmem_asciiz_t ccmem_asciiz_malloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Adapter for @cfunc{ccmem_malloc_guarded_clean} that builds and returns a new @ascii{} string.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_asciiz_malloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Adapter for @cfunc{ccmem_malloc_guarded_error} that builds and returns a new @ascii{} string.
@end deftypefun


@deftypefn {Preprocessor Macro} ccmem_asciiz_t ccmem_asciiz_malloc_guarded (cce_destination_t @var{L}, @var{S_H}, ccmem_allocator_t const * @var{A}, size_t @var{len})
Preprocessor macro that builds and returns a new @ascii{} string.  If the argument @var{S_H} is a
pointer to:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_asciiz_malloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_asciiz_malloc_guarded_error}.
@end table
@end deftypefn

@c page
@node ascii zero guarded realloc
@subsubsection Guarding memory allocated with @code{realloc}


Usage example:

@example
cce_location_t        L[1];
ccmem_clean_handler_t S_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  S = ccmem_asciiz_malloc_guarded(L, S_H,
                       ccmem_standard_allocator, 256);

  ...
  S = ccmem_asciiz_realloc_guarded(L, S_H,
        ccmem_standard_allocator, S, 512);
  ...
  cce_run_body_handlers(L);
@}
@end example


@deftypefun ccmem_asciiz_t ccmem_asciiz_realloc_guarded_clean (cce_destination_t @var{L}, ccmem_clean_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{S}, size_t @var{newlen})
Adapter for @cfunc{ccmem_realloc_guarded_clean} that builds and returns a new @asciiz{} string
representing the reallocation of @var{S}.  The given handler must be @strong{the same} handler used
in a previous call to the allocation function.
@end deftypefun


@deftypefun ccmem_asciiz_t ccmem_asciiz_realloc_guarded_error (cce_destination_t @var{L}, ccmem_error_handler_t * @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{S}, size_t @var{newlen})
Adapter for @cfunc{ccmem_realloc_guarded_error} that builds and returns a new @asciiz{} string
representing the reallocation of @var{S}.  The given handler must be @strong{the same} handler used
in a previous call to the allocation function.
@end deftypefun


@deftypefn {Preprocessor Macro} ccmem_asciiz_t ccmem_asciiz_realloc_guarded (cce_destination_t @var{L}, @var{S_H}, ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{S}, size_t @var{newlen})
Preprocessor macro that builds and returns a new @asciiz{} string representing the reallocation of
@var{S}.  The given handler must be @strong{the same} handler used in a previous call to the
allocation function.  If the argument @var{S_H} is a pointer to:

@table @code
@item ccmem_clean_handler_t
The macro use expands into a call to @cfunc{ccmem_asciiz_realloc_guarded_clean}.

@item ccmem_error_handler_t
The macro use expands into a call to @cfunc{ccmem_asciiz_realloc_guarded_error}.
@end table
@end deftypefn

@c page
@node utils
@chapter Utility definitions


@defmac CCMEM_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCMEM_PC(ccmem_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccmem_descriptor_test_failure_t * C = \
   (ccmem_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCMEM_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

